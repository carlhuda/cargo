use std::collections::HashMap;
use std::error::Error;
use std::fs::File;
use std::io::prelude::*;
use std::fmt::Write as FmtWrite;
use std::io::Write as IoWrite;
use std::iter::{self, FromIterator};

use std::ascii::AsciiExt;

fn main() {
    let options = read_txt_description()
        .expect("Failed to read options.txt");

    let description = OptionsDescription::parse(&options);
    let mut result = String::new();

    description.render(&mut result)
        .expect("Failed to generate options.rs");

    write_options_module(&result)
        .expect("Failed to write options.rs")
}

fn read_txt_description() -> Result<String, Box<Error>> {
    let mut file = File::open("src/bin/options.txt")?;
    let mut buff = String::new();
    file.read_to_string(&mut buff)?;
    Ok(buff)
}

fn write_options_module(code: &str) -> Result<(), Box<Error>> {
    let mut file = File::create("src/bin/options.rs")?;
    write!(file, "{}", code)?;
    Ok(())
}


#[derive(Debug)]
struct OptionsDescription {
    options: HashMap<String, Options>,
    commands: HashMap<String, Command>,
}

impl OptionsDescription {
    fn parse(text: &str) -> OptionsDescription {
        let chunks = text.split("\n\n\n");
        let mut options = HashMap::new();
        let mut commands = HashMap::new();
        for chunk in chunks {
            if chunk.starts_with("OPTIONS") {
                let opt = Options::parse(chunk);
                let name = opt.name.clone();
                options.insert(name, opt);
            } else if chunk.starts_with("COMMAND") {
                let cmd = Command::parse(chunk);
                let name = cmd.name.clone();
                commands.insert(name, cmd);
            }
        }

        OptionsDescription {
            options: options,
            commands: commands,
        }
    }

    fn render(&self, buff: &mut String) -> Result<(), Box<Error>> {
        writeln!(buff, "/// Generated by `generate-options.rs` from `options.txt`")?;
        writeln!(buff, "use cargo::ops::MessageFormat;\n")?;

        for cmd in self.commands.values() {
            cmd.render(buff, &self.options)?;
            writeln!(buff, "\n")?;
        }
        Ok(())
    }
}

#[derive(Debug)]
struct Options {
    name: String,
    flags: Vec<Flag>,
}

impl Options {
    fn parse(text: &str) -> Options {
        let mut lines = text.lines();
        let header = lines.next().unwrap();
        assert!(header.starts_with("OPTIONS"));
        Options {
            name: header["OPTIONS ".len()..].trim().to_string(),
            flags: Vec::from_iter(lines.map(Flag::parse)),
        }
    }
}

#[derive(Debug)]
struct Flag {
    pattern: String,
    description: String,
    type_: String,
}

impl Flag {
    fn parse(line: &str) -> Flag {
        let line = line.trim();
        let colon = line.rfind(':').unwrap();
        let type_ = line[colon + 1..].trim().to_string();
        let pattern_end = line.find("   ").unwrap();
        let pattern = line[..pattern_end].to_owned();
        Flag {
            pattern: pattern,
            description: line[pattern_end..colon].trim().to_owned(),
            type_: type_,
        }
    }

    fn render(&self, buff: &mut String) -> Result<(), Box<Error>> {
        writeln!(buff, "   pub flag_{}: {}, ", self.snake_case_name(), self.type_)?;
        Ok(())
    }

    fn snake_case_name(&self) -> String {
        let name_start = self.pattern.find("--").unwrap();
        let name = &self.pattern[name_start + 2..];
        let name_end = name.find(' ').unwrap_or(name.len());
        let name = &name[..name_end];
        name.chars()
            .map(|c| if c == '-' { '_' } else { c })
            .collect()
    }
}


#[derive(Debug)]
struct Command {
    name: String,
    pre_text: String,
    flags: Vec<FlagOrOptions>,
    post_text: String,
}

impl Command {
    fn parse(text: &str) -> Command {
        let mut lines = text.lines();
        let header = lines.next().unwrap();
        assert!(header.starts_with("COMMAND"));
        let name = header["COMMAND ".len()..].trim().to_string();

        let mut pre_text = String::new();
        let mut flags = Vec::new();
        let mut post_text = String::new();

        #[derive(Debug)]
        enum State {
            Pre,
            Flags,
            Post
        };

        let mut state = State::Pre;
        for line in lines {
            match state {
                State::Pre if line.starts_with("Options:") => state = State::Flags,
                State::Pre => writeln!(pre_text, "{}", line).unwrap(),
                State::Flags if line.is_empty() => state = State::Post,
                State::Flags => flags.push(FlagOrOptions::parse(line)),
                State::Post => writeln!(post_text, "{}", line).unwrap(),
            }
        }
        Command {
            name: name,
            pre_text: pre_text,
            flags: flags,
            post_text: post_text,
        }
    }

    fn render(&self, buff: &mut String, options: &HashMap<String, Options>)
              -> Result<(), Box<Error>> {
        let all_flags = self.all_flags(options);

        writeln!(buff, "#[derive(RustcDecodable)]\npub struct {}CommandFlags {{",
                 to_camel_case(&self.name))?;
        for flag in all_flags.iter() {
            flag.render(buff)?;
        }
        writeln!(buff, "}}")?;

        writeln!(buff, "\n")?;


        let pattern_width = all_flags.iter().map(|f| f.pattern.len()).max().unwrap();
        let help_flag = Flag::parse("        -h, --help    Print this message : ()");

        let usage_flags = iter::once(&&help_flag).chain(all_flags.iter()).map(|f| {
            format!("    {:width$}   {}\n", f.pattern, f.description, width=pattern_width)
        }).collect::<String>();

        writeln!(buff, "pub const {}_COMMAND_USAGE: &'static str = \"\
                        {}Options:\n{}\n{}\
                        \";",
                 self.name.to_ascii_uppercase(),
                 &self.pre_text,
                 usage_flags,
                 &self.post_text)?;

        Ok(())
    }

    fn all_flags<'a>(&'a self, options: &'a HashMap<String, Options>) -> Vec<&'a Flag> {
        let mut result = vec![];

        for flag in self.flags.iter() {
            match *flag {
                FlagOrOptions::Options(ref name) => {
                    let opt = options.get(name)
                        .expect(&format!("No `{}` option", name));
                    for flag in opt.flags.iter() {
                        result.push(flag)
                    }
                },
                FlagOrOptions::Flag(ref flag) => result.push(flag)
            }
        }

        result
    }
}

#[derive(Debug)]
enum FlagOrOptions {
    Flag(Flag),
    Options(String),
}

impl FlagOrOptions {
    fn parse(line: &str) -> FlagOrOptions {
        let line = line.trim();
        if line.starts_with('{') {
            assert!(line.ends_with('}'));
            FlagOrOptions::Options(line[1..line.len() - 1].to_string())
        } else {
            FlagOrOptions::Flag(Flag::parse(line))
        }
    }
}

fn to_camel_case(name: &str) -> String {
    let first = name.chars().next().unwrap();
    let rest = &name[1..];
    format!("{}{}", first.to_ascii_uppercase(), rest)
}
